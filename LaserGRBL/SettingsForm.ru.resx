<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BtnCancel.Text" xml:space="preserve">
    <value>Сброс</value>
  </data>
  <data name="BtnSave.Text" xml:space="preserve">
    <value>Сохранить</value>
  </data>
  <data name="CBSupportPWM.Text" xml:space="preserve">
    <value>Поддержка ШИМ</value>
  </data>
  <data name="label1.Text" xml:space="preserve">
    <value>LaserGRBL использует модуляцию мощности через G-Code "S командой" для получения оттенков серого.Ваш лазер должен поддерживать подключение к ардуино к PIN D11. Если нет , пожалуйста отключите поддержку ШИМ</value>
  </data>
  <data name="label2.Text" xml:space="preserve">
    <value>Режим лазера поддерживается  в версии GRBL1.1 и выше. Это приводит к отключению лазера во время быстрых ходов.Будет делать быстрые ходы , чем при резке/маркеровке</value>
  </data>
  <data name="groupBox1.Text" xml:space="preserve">
    <value>Перед началом</value>
  </data>
  <data name="$this.Text" xml:space="preserve">
    <value>Настройки</value>
  </data>
  <data name="CbAutoCooling.Text" xml:space="preserve">
    <value>Включить автоматичейское охлаждение</value>
  </data>
  <data name="CbContinuosJog.Text" xml:space="preserve">
    <value>Непрерывная работа</value>
  </data>
  <data name="CbEnableZJog.Text" xml:space="preserve">
    <value>Отображать панель управления осью Z</value>
  </data>
  <data name="CbUnidirectional.Text" xml:space="preserve">
    <value>Однонаправленная гравировка</value>
  </data>
  <data name="label10.Text" xml:space="preserve">
    <value>Без "Непрерывного толчкового режима" при нажатии кнопки толчкового режима LaserGRBL отправляет запрос толчкового режима с установленной скоростью и движением; и пробежка полностью выполняется до конечной позиции.
Если вы включите «Непрерывный толчковый режим», то толчковый режим отправляется с нажатой кнопкой мыши и прерывается / прерывается при наведении мыши, поэтому вы можете выполнять приблизительное позиционирование, но очень удобным способом.

ПРИМЕЧАНИЕ. «Непрерывный джог» работает только с Grbl v1.1 или более поздней версии и требует, чтобы размер таблицы был правильно настроен в конфигурации Grbl (меню «Grbl» -&gt; «Конфигурация Grbl»: $130, $131, $132)</value>
  </data>
  <data name="label11.Text" xml:space="preserve">
    <value>LaserGRBL не предназначен для поддержки оси Z, но если у вас есть 3-осевое оборудование, возможно, вы найдете эту опцию полезной.</value>
  </data>
  <data name="label12.Text" xml:space="preserve">
    <value>Некоторые лазерные диоды могут сильно нагреваться, если они долго работают при максимальной мощности. Чтобы предотвратить перегрев диода и увеличить срок службы лазера, вы можете добавить несколько автоматических циклов охлаждения, которые вставляют некоторую паузу во время процесса гравировки.
Если автоматическое охлаждение включено, LaserGRBL будет отправлять автоматическое «удержание подачи» и «возобновление работы» в соответствии с конфигурацией синхронизации ВКЛ-ВЫКЛ.</value>
  </data>
  <data name="label13.Text" xml:space="preserve">
    <value>Время ВКЛ .: это максимальное время, в течение которого лазер остается включённым в процессе гравировки.
По истечении этого времени LaserGRBL автоматически приостановит работу для охлаждения лазера.</value>
  </data>
  <data name="label20.Text" xml:space="preserve">
    <value>Время ВЫКЛ: после этого времени охлаждения LaserGRBL отправит команду возобновления, чтобы продолжить гравировку.</value>
  </data>
  <data name="label21.Text" xml:space="preserve">
    <value>Предупреждение: эта функция будет работать только с версиями grbl &gt; v1.1 с включенным «лазерным режимом».
Если вы используете автоматическое охлаждение с более старой версией grbl (или с отключенным лазерным режимом), лазер не выключится во время пауз
ы и прожжёт дыры в обрабатываемом материале!</value>
  </data>
  <data name="label3.Text" xml:space="preserve">
    <value>Протокол соединения:
- UsbSerial, это самый распространенный протокол. Следует использовать, если ваш гравер подключен к USB или COM-порту.
- Telnet, если у вас есть мост WiFi-Telnet. Связь осуществляется как простой клиент-сервер Telnet.
- LaserWebESP8266 поддерживает Wi-Fi соединение через WebSocket. Совместим с программным обеспечением LaserWeb-ESP8266.</value>
  </data>
  <data name="label4.Text" xml:space="preserve">
    <value>Режим потоковой передачи:
- Buffered (по умолчанию): оптимизировать потоковую передачу команд, заполняя приемный буфер grbl [рекомендуется]
- Синхронный: дождитесь выполнения каждой команды перед отправкой следующей команды [медленнее, но безопаснее]
- RepeatOnError: то же самое, что и синхронный, но повторять команды, если обнаружена ошибка [экспериментальная]</value>
  </data>
  <data name="label5.Text" xml:space="preserve">
    <value>По умолчанию LaserGRBL производит гравировальные линии в обоих направлениях перемещения лазерной головки. Некоторые тесты показали, что этот режим (который быстрее) дает результаты с более низким качеством. Если требуется максимальное качество маркировки, активируйте эту опцию.</value>
  </data>
  <data name="label6.Text" xml:space="preserve">
    <value>Режим потоков: UltraFast, Fast, Quiet, Slow. [По умолчанию Fast]
Этот параметр влияет на скорость отправки потока и частоту запроса отчета о состоянии.
Установите более медленные значения, если у вас возникли проблемы.</value>
  </data>
  <data name="label7.Text" xml:space="preserve">
    <value>LaserGRBL может обнаружить проблемы и предупредить пользователя, предоставив информацию о том, как их решить.
Если отключено, все проблемы управляются без предупреждения.</value>
  </data>
  <data name="label8.Text" xml:space="preserve">
    <value>Если включен LaserGRBL, отправьте полный сброс при открытии соединения с grbl. [Позиция потеряна!]</value>
  </data>
  <data name="label9.Text" xml:space="preserve">
    <value>Тип прошивки
- Grbl: потрясающая прошивка, для которой была разработана LaserGRBL.
- Smoothie [экспериментальная]: поддержка была добавлена недавно и не полностью протестирована.</value>
  </data>
  <data name="TpAutoCooling.Text" xml:space="preserve">
    <value>Автоматическое охлаждение</value>
  </data>
  <data name="TpHardware.Text" xml:space="preserve">
    <value>Протокол</value>
  </data>
  <data name="TpJogControl.Text" xml:space="preserve">
    <value>Контроль работы</value>
  </data>
  <data name="TpRasterImport.Text" xml:space="preserve">
    <value>Импорт растра</value>
  </data>
  <data name="CbIssueDetector.Text" xml:space="preserve">
    <value>Детектор проблем</value>
  </data>
  <data name="label15.Text" xml:space="preserve">
    <value>мин.</value>
  </data>
  <data name="label14.Text" xml:space="preserve">
    <value>Вкл.</value>
  </data>
  <data name="label16.Text" xml:space="preserve">
    <value>сек.</value>
  </data>
  <data name="label17.Text" xml:space="preserve">
    <value>мин.</value>
  </data>
  <data name="label18.Text" xml:space="preserve">
    <value>Выкл.</value>
  </data>
  <data name="label19.Text" xml:space="preserve">
    <value>сек.</value>
  </data>
  <data name="LblHeader.Text" xml:space="preserve">
    <value>LaserGRBL выполнит этот код перед началом любой работы.
Вы можете настроить его под себя, к примеру, добавив M8, чтобы включить вентилятор.

Можно использовать тот же синтаксис, что и в пользовательских кнопках.</value>
  </data>
  <data name="groupBox2.Text" xml:space="preserve">
    <value>После окончания</value>
  </data>
  <data name="groupBox3.Text" xml:space="preserve">
    <value>Между проходами</value>
  </data>
  <data name="LblFooter.Text" xml:space="preserve">
    <value>LaserGRBL отправит этот код в конце работы.
Можно использовать это для восстановления начального состояния гравёра, например, отправив M9 чтобы отключить вентилятор.

Можно использовать тот же синтаксис, что и в пользовательских кнопках.</value>
  </data>
  <data name="LblPasses.Text" xml:space="preserve">
    <value>Код, который будет выполнен между проходами.
Можно использовать, чтобы опустить лазер по оси Z для резки на большей глубине.

Можно использовать тот же синтаксис, что и в пользовательских кнопках.</value>
  </data>
</root>